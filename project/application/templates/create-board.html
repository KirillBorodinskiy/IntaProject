{% load static %}
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Create your board</title>
    <link rel="stylesheet" type="text/css" href="{% static 'application/styles.css' %}">
</head>
<body>
    <div class="container">
        <div class="currentShip">
            <div id="Ships">
                {% for ship in ShipList%}
                    <div class="ship ship{{ship}}"></div>

                    <input type="radio" class="Ship{{ship}}Select" name="shipLength" value="ship{{ship}}">
                    <label for="vertical">Ship {{ship}}</label>
                {% endfor %}
            </div>
            <div>
                <input type="radio" id="vertical" name="options" value="vertical">
                <label for="vertical">Vertical</label>
            </div>
            <div>
                <input type="radio" id="horizontal" name="options" value="horizontal" checked>
                <label for="horizontal">Horizontal</label>
            </div>
        </div>
        <div class="grid grid1">
            {% for row_index, row in board.items %} 
                {% for col_index, cell in row.items %}
                    <div id ="grid{{row_index}}{{col_index}}" data-hidden-value="0" class="block block1" data-row="{{ row_index }}" data-col="{{ col_index }}" 
                         onclick="updateHiddenFieldsAndSubmit({{ row_index }}, {{ col_index }})"
                         {% if cell %} occupied {% endif %}>
                        {% if cell %} {{ cell }} {% endif %} 
                    </div>
                {% endfor %}
            {% endfor %}
        </div>
        <button type="submit" onclick="getBoard()">Send it!</button>

        <script>
            selectNextAvailableShip();

            function updateGameCell(gameId, row, col, value) {
                // Create the data object to send
                const data = {
                    game_id: gameId,
                    row: row,
                    col: col,
                    value: value
                };
            
                // Get the CSRF token (if needed)
                const csrftoken = getCookie('csrftoken');
            
                // Send a POST request to the Django backend
                fetch('/update-cell/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrftoken // Only if CSRF protection is enabled
                    },
                    body: JSON.stringify(data)
                })
                .then(response => response.json())
                .then(result => {
                    if (result.status === 'success') {
                        console.log('Cell updated successfully');
                    } else {
                        console.error('Error updating cell:', result.message);
                    }
                })
                .catch(error => {
                    console.error('Request failed:', error);
                });
            }
            function getBoard(){
                const board = [];

                for (let row_index = 0; row_index < 10; row_index++) {
                  const row = [];
                  for (let col_index = 0; col_index < 10; col_index++) {
                    row.push(document.getElementById("grid"+row_index+col_index).dataset.hiddenValue); 
                  }
                  board.push(row);
                }
                return board;
            }

            function getCookie(name) {
                let cookieValue = null;
                if (document.cookie && document.cookie !== '') {
                    const cookies = document.cookie.split(';');
                    for (let i = 0; i < cookies.length; i++) {
                        const cookie = cookies[i].trim();
                        if (cookie.substring(0, name.length + 1) === (name + '=')) {
                            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                            break;
                        }
                    }
                }
                return cookieValue;
            }

            
            function updateHiddenFieldsAndSubmit(row, col) {
                // Get the ID of the grid cell being clicked
                const gridId = "grid" + row + col;
            
                // Check if the orientation is vertical
                const isVertical = document.getElementById("vertical").checked;
            
                // Find the length of the currently selected ship
                const selectedShipLength = findSelectedShipLength();
            
                // If no ship is selected, alert the user and return
                if (!selectedShipLength) {
                    document.getElementsByClassName("Ship4Select")[0].checked=true;
                    return;
                }
            
                // Check if the maximum number of ships of the selected length has been placed
                if (hasReachedMaxShips(selectedShipLength)) {
                    // If the max is reached, select the next available ship checkbox
                    selectNextAvailableShip();
                    return; 
                }
            
                // Check if the ship can be placed at the specified location
                if (!canPlaceShipAt(row, col, selectedShipLength, isVertical)) {
                    alert("Cannot place ship here. There are adjacent ships or it's out of bounds!");
                    return;
                }
            
                // Place the ship on the grid
                placeShip(row, col, selectedShipLength, isVertical);
            
                // Find the first ship element (representing the placed ship) that's not already colored and update it
                const shipElements = document.getElementsByClassName("ship" + selectedShipLength);
                for (const element of shipElements) {
                    if (element.style.backgroundColor != "rgb(76, 175, 80)") {
                        element.style.backgroundColor = "rgb(76, 175, 80)";
                        break; 
                    }
                }
            }
            
            // Function to find the length of the currently selected ship
            function findSelectedShipLength() {
                for (let ShipLength = 1; ShipLength < 5; ShipLength++) {
                    const currentShip = "Ship" + ShipLength + "Select";
                    const isChecked = Array.from(document.getElementsByClassName(currentShip)).some(element => element.checked);
                    if (isChecked) {
                        return ShipLength;
                    }
                }
                return null; 
            }
            
            // Function to check if the maximum number of ships of a given length has been placed
            function hasReachedMaxShips(shipLength) {
                const placedShips = Array.from(document.getElementsByClassName("ship" + shipLength))
                    .filter(element => element.style.backgroundColor == "rgb(76, 175, 80)")
                    .length;
                return placedShips >= (5 - shipLength); 
            }
            
            // Function to check if a ship can be placed at a given location
            function canPlaceShipAt(row, col, shipLength, isVertical) {
                for (let i = 0; i < shipLength; i++) {
                    const currentRow = isVertical ? row + i : row;
                    const currentCol = isVertical ? col : col + i;
            
                    // Check if the placement is within the grid bounds
                    if (currentRow < 0 || currentRow >= 10 || currentCol < 0 || currentCol >= 10) {
                        return false; 
                    }
            
                    // Check the current cell and its adjacent cells for existing ships
                    for (let r = currentRow - 1; r <= currentRow + 1; r++) {
                        for (let c = currentCol - 1; c <= currentCol + 1; c++) {
                            if (r >= 0 && r < 10 && c >= 0 && c < 10) {
                                const adjacentGridId = "grid" + r + c;
                                if (document.getElementById(adjacentGridId).dataset.hiddenValue == 1) {
                                    return false; 
                                }
                            }
                        }
                    }
                }
                return true; 
            }
            
            // Function to place a ship on the grid
            function placeShip(row, col, shipLength, isVertical) {
                const newColor = "rgb(76, 175, 80)"; 
            
                for (let i = 0; i < shipLength; i++) {
                    const currentGridId = isVertical ? "grid" + (row + i) + col : "grid" + row + (col + i);
            
                    const currentCell = document.getElementById(currentGridId);
                    if (currentCell) { 
                        currentCell.dataset.hiddenValue = 1; 
                        currentCell.style.backgroundColor = newColor;
                    }
                }
            }
            
            // New function to select the next available ship checkbox
            function selectNextAvailableShip() {
                for (let shipLength = 4; shipLength > 0; shipLength--) {
                    if (!hasReachedMaxShips(shipLength)) {
                        // Get all checkboxes for this ship length
                        const checkboxes = document.getElementsByClassName("Ship" + shipLength + "Select");
            
                        // Check the first one that's not already checked
                        for (const checkbox of checkboxes) {
                            if (!checkbox.checked) {
                                checkbox.checked = true;
                                break;
                            }
                        }
                        break; // Exit the outer loop once a checkbox is selected
                    }
                }
            }
            
            
        </script>
    </body>
</html>